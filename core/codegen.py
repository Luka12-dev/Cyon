from __future__ import annotations

import os
import re
import textwrap
import itertools
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Tuple, Callable

# Import AST node classes from parser; support both package and direct imports
try:
    from .parser import (
        Program, FunctionDecl, VarDecl, IfStmt, WhileStmt, ForStmt, ReturnStmt,
        BreakStmt, ContinueStmt, Literal, Identifier, BinaryOp, UnaryOp,
        CallExpr, ArrayExpr, IndexExpr, Node
    )
except Exception:
    from core.parser import (
        Program, FunctionDecl, VarDecl, IfStmt, WhileStmt, ForStmt, ReturnStmt,
        BreakStmt, ContinueStmt, Literal, Identifier, BinaryOp, UnaryOp,
        CallExpr, ArrayExpr, IndexExpr, Node
    )

def escape_c_string(s: str) -> str:
    s = s.replace("\\", "\\\\")
    s = s.replace('"', '\"')
    s = s.replace("\n", "\\n")
    s = s.replace("\t", "\\t")
    s = s.replace("\r", "\\r")
    return s


def unique_name(prefix: str, _counter=itertools.count()):
    return f"_{prefix}_{next(_counter)}"


# Simple indenter used by generator
@dataclass
class Indenter:
    level: int = 0
    indent_str: str = "    "

    def inc(self):
        self.level += 1

    def dec(self):
        self.level = max(0, self.level - 1)

    def __call__(self, line: str = "") -> str:
        if line == "":
            return "\n"
        return f"{self.indent_str * self.level}{line}\n"

@dataclass
class Symbol:
    name: str
    c_name: str
    typ: Optional[str] = None

class SymbolTable:
    def __init__(self, parent: Optional["SymbolTable"] = None):
        self.parent = parent
        self.symbols: Dict[str, Symbol] = {}

    def define(self, name: str, c_name: Optional[str] = None, typ: Optional[str] = None) -> Symbol:
        if c_name is None:
            c_name = name
        sym = Symbol(name=name, c_name=c_name, typ=typ)
        self.symbols[name] = sym
        return sym

    def lookup(self, name: str) -> Optional[Symbol]:
        if name in self.symbols:
            return self.symbols[name]
        if self.parent:
            return self.parent.lookup(name)
        return None

@dataclass
class CodeGenConfig:
    runtime_header: str = "\"runtime.h\""
    runtime_lib: str = "-lcyon"
    target_c_version: str = "c99"

class CodeGenerator:
    def __init__(self, config: Optional[CodeGenConfig] = None):
        self.config = config or CodeGenConfig()
        self.indent = Indenter()
        self.lines: List[str] = []
        self.global_symbols = SymbolTable()
        self.current_symbols: Optional[SymbolTable] = None
        self.func_counter = itertools.count()

    def emit(self, s: str = "") -> None:
        self.lines.append(self.indent(s))

    def emit_raw(self, s: str) -> None:
        # write raw block (may contain multiple lines)
        for line in s.splitlines():
            self.lines.append(self.indent(line))

    def header(self, program: Program) -> None:
        self.emit("/* Generated by Cyon CodeGenerator */")
        self.emit(f"#include {self.config.runtime_header}")
        self.emit("#include <stdlib.h>")
        self.emit("#include <stdio.h>")
        self.emit("#include <string.h>")
        self.emit("")

    def footer(self) -> None:
        # optional footer hooks
        self.emit("")

    def result(self) -> str:
        return "".join(self.lines)

    def generate_program(self, program: Program) -> str:
        self.lines = []
        self.header(program)
        # pre-declare function signatures
        for node in program.body:
            if isinstance(node, FunctionDecl):
                sig = self.function_signature_decl(node)
                self.emit(sig)
        self.emit("")
        # generate function bodies
        for node in program.body:
            if isinstance(node, FunctionDecl):
                self.generate_function(node)
            else:
                # top-level expressions/vars can be wrapped in init function
                self.generate_top_level(node)
        self.footer()
        return self.result()

    def function_signature_decl(self, node: FunctionDecl) -> str:
        # For now all functions return int for simplicity; "main" returns int
        params = ", ".join("int %s" % p for p in node.params)
        if node.name == "main":
            return "int main(void);"
        return f"int {node.name}({params});"

    def generate_top_level(self, node: Node) -> None:
        # Currently we do not support top-level code besides functions.
        # Could be extended to create a module init function.
        self.emit("/* top-level code generation not yet implemented */")

    def generate_function(self, node: FunctionDecl) -> None:
        # create a new symbol table for the function
        self.current_symbols = SymbolTable(self.global_symbols)
        params_decl = ", ".join(f"int {p}" for p in node.params)
        if node.name == "main":
            self.emit("int main(void) {")
        else:
            self.emit(f"int {node.name}({params_decl}) {{")
        self.indent.inc()
        # define parameters in symbol table
        for p in node.params:
            self.current_symbols.define(p, c_name=p, typ="int")
        # generate body
        for stmt in node.body:
            self.generate_statement(stmt)
        # default return
        if node.name == "main":
            self.emit("return 0;")
        else:
            self.emit("return 0;")
        self.indent.dec()
        self.emit("}")
        self.emit("")
        # clear current symbols
        self.current_symbols = None

    def generate_statement(self, node: Node) -> None:
        if isinstance(node, VarDecl):
            self.generate_vardecl(node)
        elif isinstance(node, IfStmt):
            self.generate_if(node)
        elif isinstance(node, WhileStmt):
            self.generate_while(node)
        elif isinstance(node, ForStmt):
            self.generate_for(node)
        elif isinstance(node, ReturnStmt):
            self.generate_return(node)
        elif isinstance(node, BreakStmt):
            self.emit("break;")
        elif isinstance(node, ContinueStmt):
            self.emit("continue;")
        elif isinstance(node, Node):
            # expression statements
            expr_c = self.generate_expression(node)
            if expr_c is not None:
                self.emit(f"{expr_c};")
        else:
            self.emit(f"/* unhandled statement type: {node.__class__.__name__} */")

    def generate_vardecl(self, node: VarDecl) -> None:
        name = node.name
        c_name = name
        if node.value:
            expr_c = self.generate_expression(node.value)
            self.emit(f"int {c_name} = {expr_c};")
            if self.current_symbols:
                self.current_symbols.define(name, c_name=c_name, typ="int")
        else:
            self.emit(f"int {c_name} = 0;")
            if self.current_symbols:
                self.current_symbols.define(name, c_name=c_name, typ="int")

    def generate_if(self, node: IfStmt) -> None:
        cond_c = self.generate_expression(node.condition)
        self.emit(f"if ({cond_c}) {{")
        self.indent.inc()
        for s in node.then_branch:
            self.generate_statement(s)
        self.indent.dec()
        self.emit("}")
        if node.else_branch:
            self.emit("else {")
            self.indent.inc()
            for s in node.else_branch:
                self.generate_statement(s)
            self.indent.dec()
            self.emit("}")

    def generate_while(self, node: WhileStmt) -> None:
        cond_c = self.generate_expression(node.condition)
        self.emit(f"while ({cond_c}) {{")
        self.indent.inc()
        for s in node.body:
            self.generate_statement(s)
        self.indent.dec()
        self.emit("}")

    def generate_for(self, node: ForStmt) -> None:
        # for now support simple "for i in arr" where arr is an array variable
        it = node.iterator or "i"
        iterable_c = self.generate_expression(node.iterable) if node.iterable else "0"
        tmp_arr = unique_name("arr")
        self.emit(f"/* for-loop placeholder: iterator={it} iterable={iterable_c} */")
        self.emit(f"int {it} = 0;")
        self.emit(f"for ({it} = 0; {it} < 0; ++{it}) {{")
        self.indent.inc()
        for s in node.body:
            self.generate_statement(s)
        self.indent.dec()
        self.emit("}")

    def generate_return(self, node: ReturnStmt) -> None:
        if node.value:
            expr_c = self.generate_expression(node.value)
            self.emit(f"return {expr_c};")
        else:
            self.emit("return 0;")

    def generate_expression(self, node: Node) -> Optional[str]:
        if isinstance(node, Literal):
            return self.gen_literal(node)
        if isinstance(node, Identifier):
            return self.gen_identifier(node)
        if isinstance(node, BinaryOp):
            left = self.generate_expression(node.left)
            right = self.generate_expression(node.right)
            op = node.op
            # map logical operators to C equivalents if necessary
            op_map = {"and": "&&", "or": "||"}
            op = op_map.get(op, op)
            return f"({left} {op} {right})"
        if isinstance(node, UnaryOp):
            operand = self.generate_expression(node.operand)
            return f"({node.op}{operand})"
        if isinstance(node, CallExpr):
            return self.gen_call(node)
        if isinstance(node, ArrayExpr):
            # arrays are currently unsupported as first-class values in C
            # This will allocate on stack or use runtime functions later
            elems = [self.generate_expression(e) for e in node.elements]
            return self.gen_array_literal(elems)
        if isinstance(node, IndexExpr):
            col = self.generate_expression(node.collection)
            idx = self.generate_expression(node.index)
            return f"({col})[{idx}]"
        # fallback
        return f"/*?expr:{node.__class__.__name__}?*/0"

    def gen_literal(self, node: Literal) -> str:
        v = node.value
        if isinstance(v, str):
            return f"(char*) \"{escape_c_string(v)}\""
        if isinstance(v, bool):
            return "1" if v else "0"
        if v is None:
            return "0"
        return str(v)

    def gen_identifier(self, node: Identifier) -> str:
        # lookup symbol for name mapping
        name = node.name
        sym = self.current_symbols.lookup(name) if self.current_symbols else None
        if sym:
            return sym.c_name
        return name

    def gen_call(self, node: CallExpr) -> str:
        callee = node.callee
        if isinstance(callee, Identifier) and callee.name == "print":
            # special-case print to runtime function
            if node.args and len(node.args) == 1:
                arg = self.generate_expression(node.args[0])
                return f"(cyon_print({arg}), 0)"
            # join args
            args_c = ", ".join(self.generate_expression(a) for a in node.args)
            return f"(cyon_print_formatted({args_c}), 0)"
        callee_c = self.generate_expression(callee)
        args_c = ", ".join(self.generate_expression(a) for a in node.args)
        return f"{callee_c}({args_c})"

    def gen_array_literal(self, elems: List[str]) -> str:
        # create a static array literal in C and return pointer
        # in a real implementation this would allocate and manage memory
        arr_name = unique_name("arrlit")
        elems_c = ", ".join(elems) if elems else "0"
        # emit static definition before current function body? For now, inline as VLA
        return f"({{ {elems_c} }})"

class Optimizer:
    def __init__(self):
        self.passes: List[Callable[[Program], Program]] = [
            self.constant_folding,
            self.dead_code_elimination,
            self.trivial_inlining,
        ]

    def optimize(self, program: Program) -> Program:
        p = program
        for fn in self.passes:
            try:
                p = fn(p)
            except Exception:
                # be resilient: log and continue
                print(f"Optimizer pass {fn.__name__} failed, continuing...")
        return p

    def constant_folding(self, program: Program) -> Program:
        # Walk AST and fold BinaryOp(Literal, Literal)
        def fold_node(node: Node) -> Node:
            if isinstance(node, BinaryOp):
                left = fold_node(node.left)
                right = fold_node(node.right)
                if isinstance(left, Literal) and isinstance(right, Literal):
                    try:
                        return Literal(eval(f"{repr(left.value)} {node.op} {repr(right.value)}"))
                    except Exception:
                        return BinaryOp(left=left, op=node.op, right=right)
                return BinaryOp(left=left, op=node.op, right=right)
            # recurse for generic nodes
            for field, value in list(getattr(node, "__dict__", {}).items()):
                if isinstance(value, list):
                    newlist = []
                    changed = False
                    for item in value:
                        if isinstance(item, Node):
                            ni = fold_node(item)
                            newlist.append(ni)
                            if ni is not item:
                                changed = True
                        else:
                            newlist.append(item)
                    if changed:
                        setattr(node, field, newlist)
                elif isinstance(value, Node):
                    nv = fold_node(value)
                    if nv is not value:
                        setattr(node, field, nv)
            return node

        # apply to each top-level function body
        for i, item in enumerate(program.body):
            if isinstance(item, FunctionDecl):
                new_body = []
                for stmt in item.body:
                    new_body.append(fold_node(stmt))
                item.body = new_body
        return program

    def dead_code_elimination(self, program: Program) -> Program:
        # Remove statements after a ReturnStmt within the same block
        for item in program.body:
            if isinstance(item, FunctionDecl):
                new_body: List[Node] = []
                for stmt in item.body:
                    new_body.append(stmt)
                    if isinstance(stmt, ReturnStmt):
                        break
                item.body = new_body
        return program

    def trivial_inlining(self, program: Program) -> Program:
        # Inline functions that are a single return of a literal or simple expr
        inline_map: Dict[str, Node] = {}
        for item in program.body:
            if isinstance(item, FunctionDecl):
                if len(item.body) == 1 and isinstance(item.body[0], ReturnStmt) and isinstance(item.body[0].value, Literal):
                    inline_map[item.name] = item.body[0].value
        # replace call sites
        def replace(node: Node) -> Node:
            if isinstance(node, CallExpr) and isinstance(node.callee, Identifier) and node.callee.name in inline_map:
                return inline_map[node.callee.name]
            for field, value in list(getattr(node, "__dict__", {}).items()):
                if isinstance(value, list):
                    node_list = []
                    for it in value:
                        if isinstance(it, Node):
                            node_list.append(replace(it))
                        else:
                            node_list.append(it)
                    setattr(node, field, node_list)
                elif isinstance(value, Node):
                    setattr(node, field, replace(value))
            return node

        for item in program.body:
            if isinstance(item, FunctionDecl):
                item.body = [replace(s) for s in item.body]
        return program

@dataclass
class CompileResult:
    c_source: str
    c_filename: str
    success: bool = True
    errors: List[str] = field(default_factory=list)


def compile_program_to_c(program: Program, out_c: str = "out.c") -> CompileResult:
    gen = CodeGenerator()
    opt = Optimizer()
    prog_opt = opt.optimize(program)
    c_src = gen.generate_program(prog_opt)
    return CompileResult(c_source=c_src, c_filename=out_c)

SAMPLE_SNIPPET = r"""
/* Example generated snippet: arithmetic and print */
void _sample_arith() {
    int a = 10;
    int b = 20;
    int c = (a + b) * 2;
    cyon_print("Result: ");
    cyon_print_int(c);
}

"""

# Build a long sample by repeating the snippet multiple times with unique names
LARGE_SAMPLE = []
for i in range(180):
    LARGE_SAMPLE.append(SAMPLE_SNIPPET.replace("_sample_arith", f"_sample_arith_{i}"))

LARGE_SAMPLE_TEXT = "\n".join(LARGE_SAMPLE)

# Append to module-level doc for discoverability (not executed)
_DETAILED_EXAMPLES = f"""
Huge example section (auto-generated) below - used for tests and docs.
{LARGE_SAMPLE_TEXT}
"""

def dump_generated_c(result: CompileResult, path: Optional[str] = None) -> None:
    target = path or result.c_filename
    with open(target, "w", encoding="utf-8") as f:
        f.write(result.c_source)


def compile_with_gcc(c_file: str, out_exe: str = "a.out") -> Tuple[bool, str]:
    gcc = os.environ.get("CC", "gcc")
    cmd = f"{gcc} -std=c99 -O2 -o {out_exe} {c_file}"
    # link with libcyon if present in config; users will integrate runtime
    try:
        import subprocess
        proc = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        if proc.returncode != 0:
            return False, proc.stderr
        return True, proc.stdout
    except Exception as e:
        return False, str(e)

__all__ = [
    "CodeGenerator", "compile_program_to_c", "CompileResult",
    "dump_generated_c", "compile_with_gcc", "Optimizer",
]

LONG_DOC_BLOCK = r"""
Cyon Codegen: Large Example Corpus

This block contains many repeated examples and C code fragments which
serve multiple purposes:
 - Exercise codegen paths with many combinations of nodes.
 - Provide sample generated C to include in docs or tests.
 - Help with manual inspection during development.

Below we include many variants of simple functions, arithmetic, loops,
and calls to runtime functions. These snippets are synthetic but
representative.

"""

# Append many verbose example fragments
for n in range(200):
    LONG_DOC_BLOCK += f"\n/* fragment #{n} */\n"
    LONG_DOC_BLOCK += "void _fragment_%d() {\n    int i = 0;\n    for (i = 0; i < 10; ++i) {\n        cyon_print_int(i);\n    }\n}\n" % n